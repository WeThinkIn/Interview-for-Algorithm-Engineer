# 目录
# C++基础篇
- [1.C/C++中面向对象的相关知识](#1.cc中面向对象的相关知识)
- [2.C/C++中struct的内存对齐与内存占用计算？](#2.cc中struct的内存对齐与内存占用计算？)
- [3.C/C++中智能指针的定义与作用？](#3.cc中智能指针的定义与作用？)
- [4.C/C++中程序的开发流程？](#4.cc中程序的开发流程？)
- [5.C/C++中数组和链表的优缺点？](#5.cc中数组和链表的优缺点？)
- [6.C/C++中的new和malloc有什么区别？](#6.cc中的new和malloc有什么区别？)
- [7.C/C++中野指针的概念？](#7.cc中野指针的概念？)
- [8.C/C++中内存泄漏以及解决方法？](#8.cc中内存泄漏以及解决方法？)
- [9.C/C++中面向对象和面向过程的区别？](#9.cc中面向对象和面向过程的区别？)
- [10.C/C++中常用容器功能汇总](#10.cc中常用容器功能汇总)
  - [vector（数组）](#vector（数组）)
  - [queue（队列）](#queue（队列）)
  - [deque（双端队列）](#deque（双端队列）)
  - [set（集合）](#set（集合）)
  - [unordered_set（无序集合）](#unordered_set（无序集合）)
  - [unordered_map](#unordered_map)
- [11.C/C++中指针和引用的区别](#11.cc中指针和引用的区别)
- [12.C/C++中宏定义的相关知识](#12.cc中宏定义的相关知识)
- [13.C/C++中typedef关键字的相关知识](#13.cc中typedef关键字的相关知识)
- [14.声明和定义的区别是什么？](#14.声明和定义的区别是什么？)
- [15.i++和++i哪个执行效率高](#15.i++和++i哪个执行效率高)
- [16.数组名是什么？](#16.数组名是什么？)
- [17.C++中小数用二进制如何表示？](#17.C++中小数用二进制如何表示)
- [18.C++中什么是大端、小端？](#18.C++中什么是大端、小端？)
- [19.C++里有哪些类型转换运算符？](#19.C++里有哪些类型转换运算符？)
- [20.C++中赋值与初始化的区别](#20.C++中赋值与初始化的区别)
- [21.C++中异常处理机制](#21.C++中异常处理机制)
- [22.C++中new、delete、malloc、free关系](#22.C++中new、delete、malloc、free关系)
- [23.介绍一下register关键字](#23.介绍一下register关键字)
- [24.介绍一下const关键字](#24.介绍一下const关键字)
- [25.C++中介绍一下delete与 delete []区别](#25.C++中介绍一下delete与delete[]区别)
- [26.介绍一下newoperator和operatornew的区别](#26.介绍一下newoperator和operatornew的区别)
- [27.介绍一下external关键字](#27.介绍一下external关键字)
- [28.介绍一下volatile关键字](#28.C介绍一下volatile关键字)
- [29.介绍一下dynamic在什么时候使用](#29.介绍一下dynamic在什么时候使用)
- [30.介绍一下vector优缺点](#30.介绍一下vector优缺点)
- [31.介绍一下list优缺点](#31.介绍一下list优缺点)
- [32.介绍一下deque优缺点](#32.介绍一下deque优缺点)
- [33.介绍一下map&set优缺点](#33.介绍一下list优缺点)
- [34.介绍一下mutable关键字的作用](#34.介绍一下deque优缺点)
- [35.什么时候用static](#35.什么时候用static)
- [36.容器选择的原则](#36.容器选择的原则)
- [37.什么是迭代器，有哪几种迭代器](#37.什么是迭代器，有哪几种迭代器)
- [38.什么是指针数组、什么是数组指针](#38.什么是指针数组、什么是数组指针)
- [39.指针与数组的区别](#39.指针与数组的区别)
- [40.引用和指针的区别](#40.引用和指针的区别)
- [41.什么是内联函数](#41.什么是内联函数)
- [42.宏函数和自定义函数的区别](#42.宏函数和自定义函数的区别)
- [43.函数调用的步骤](#43.函数调用的步骤)
- [44.什么是纯虚函数抽象类](#44.什么是纯虚函数抽象类)
- [45.函数重载条件](#45.函数重载条件)
- [46.构造函数的特点](#46.构造函数的特点)
- [47.什么是析构函数、析构函数的作用](#47.什么是析构函数、析构函数的作用)
- [48.C++定义常量两种方式是什么？](#48.C++定义常量两种方式是什么？)
- [49.重载函数是否能够通过函数返回值的类型不同来区分？](#49.重载函数是否能够通过函数返回值的类型不同来区分？)
- [50.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”](#50.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”)
- [51.头文件中的ifndef/define/endif有什么作用？](#51.头文件中的ifndef/define/endif有什么作用？)
- [52.＃include<file.h> 与 ＃include "file.h"的区别？](#52.＃include<file.h>与＃include"file.h"的区别？)
- [53.介绍一下C/C++各自的特点？](#53.介绍一下C/C++各自的特点？)
- [54.介绍一下const 用途？](#54.介绍一下const用途？)
- [55.const和#define有什么区别？](#55.const和#define有什么区别？)
- [56.什么是多态？多态有什么作用？](#56.什么是多态？多态有什么作用？)
- [57.重载和覆盖有什么区别？](#57.重载和覆盖有什么区别？)
- [58.空指针和悬垂指针的区别？](#58.空指针和悬垂指针的区别？)
- [59.什么是智能指针？](#59.什么是智能指针？)
- [60.C++空类默认有哪些成员函数？](#60.C++空类默认有哪些成员函数？)
- [61.C++哪一种成员变量可以在一个类的实例之间共享？](#61.C++哪一种成员变量可以在一个类的实例之间共享？)
- [62.继承层次中，为什么基类析构函数是虚函数？](#62.继承层次中，为什么基类析构函数是虚函数？)


<h2 id="1.cc中面向对象的相关知识">1.C/C++中面向对象的相关知识</h2>
  
面向对象程序设计（Object-oriented programming，OOP）有三大特征 ——封装、继承、多态。

<font color=DeepSkyBlue>封装</font>：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
关键字：public, protected, private。不写默认为 private。
1. public 成员：可以被任意实体访问。

2. protected 成员：只允许被子类及本类的成员函数访问。

3. private 成员：只允许被本类的成员函数、友元类或友元函数访问。

<font color=DeepSkyBlue>继承</font>：基类（父类）——> 派生类（子类）

<font color=DeepSkyBlue>多态</font>：即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。多态是以封装和继承为基础的。

C++ 多态分类及实现：

1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载

2. 子类型多态（Subtype Polymorphism，运行期）：虚函数

3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板

4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

<h2 id="2.cc中struct的内存对齐与内存占用计算？">2.C/C++中struct的内存对齐与内存占用计算？</h2>

<font color=DeepSkyBlue>什么是内存对齐？</font>计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是有效对齐值的倍数。

<font color=DeepSkyBlue>什么是有效对齐值？</font>计算机系统有默认对齐系数n,可以通过#pragma pack(n)来指定。有效对齐值就等与该对齐系数和结构体中最长的数据类型的长度两者最小的那一个值,比如对齐系数是8,而结构体中最长的是int,4个字节,那么有效对齐值为4。
  
<font color=DeepSkyBlue>为什么要内存对齐？</font>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中。当4字节存取粒度的处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作，整体效率较低。

![](https://files.mdnice.com/user/33499/a93de1ee-1369-4d06-bb7a-136990981fa2.png)

<font color=DeepSkyBlue>struct内存占用如何计算？</font>结构体的内存计算方式遵循以下规则：

1. 数据成员对齐规则：第一个数据成员放在offset为0的地方，以后的每一个成员的offset都必须是该成员的大小与有效对齐值相比较小的数值的整数倍,例如第一个数据成员是int型，第二个是double，有效对齐值为8,所以double的起始地址应该为8,那么第一个int加上内存补齐用了8个字节

2. 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部有效对齐值的整数倍地址开始存储。(比如struct a中存有struct b，b里有char, int, double，那b应该从8的整数倍开始存储)

3. 结构体内存的总大小，必须是其有效对齐值的整数倍，不足的要补齐。

我们来举两个🌰：

```
#include <stdio.h>
#pragma pack(8)
int main()
{
  struct Test
  {
    int a;
    //long double大小为16bytes
    long double b;         
    char c[10];
  };
  printf("%d", sizeof(Test));
  return 0;
} 

struct的内存占用为40bytes
```

```
#include <stdio.h>
#pragma pack(16)
int main()
{
  struct Test
  {
    int a;
    //long double大小为16bytes
    long double b;         
    char c[10];
  }
  printf("%d", sizeof(Test));
  return 0;
}

struct的内存占用为48bytes
```

<h2 id="3.cc中智能指针的定义与作用？">3.C/C++中智能指针的定义与作用？</h2>
  
智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。

（注：不能将指针直接赋值给一个智能指针，一个是类，一个是指针。）

<font color=DeepSkyBlue>常用的智能指针</font>：智能指针在C++11版本之后提供，包含在头文件<memory>中，主要是shared_ptr、unique_ptr、weak_ptr。<font color=DeepSkyBlue>unique_ptr</font>不支持复制和赋值。当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果原来的unique_ptr 将存在一段时间，编译器将禁止这么做。<font color=DeepSkyBlue>shared_ptr</font>是基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。<font color=DeepSkyBlue>weak_ptr</font>能进行弱引用。引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。

<font color=DeepSkyBlue>智能指针的作用</font>：C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，野指针，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

<h2 id="4.cc中程序的开发流程？">4.C/C++中程序的开发流程？</h2>
  
开发一个C++程序的过程通常包括编辑、编译、链接、运行和调试等步骤。

<font color=DeepSkyBlue>编辑</font>：编辑是C++程序开发过程的第一步，它主要包括程序文本的输入和修改。任何一种文本编辑器都可以完成这项工作。当用户完成了C++程序的编辑时，应将输入的程序文本保存为以.cpp为扩展名的文件（保存C++头文件时应以.h为扩展名）。

<font color=DeepSkyBlue>编译</font>：C++是一种高级程序设计语言，它的语法规则与汇编语言和机器语言相比更接近人类自然语言的习惯。然而，计算机能够“看”懂的唯一语言是汇编语言。因此，当我们要让计算机“看”懂一个C++程序时，就必须使用编译器将这个C++程序“翻译”成汇编语言。编译器所做的工作实际上是一种由高级语言到汇编语言的等价变换。

<font color=DeepSkyBlue>汇编</font>：将汇编语言翻译成机器语言指令。汇编器对汇编语言进行一系列处理后最终产生的输出结构称为目标代码，它是某种计算机的机器指令（二进制），并且在功能上与源代码完全等价。保存源代码和目标代码的文件分别称为源文件和目标文件（ .obj）。

<font color=DeepSkyBlue>链接</font>：要将汇编器产生的目标代码变成可执行程序还需要最后一个步骤——链接。链接工作是由“链接器”完成的，它将编译后产生的一个或多个目标文件与程序中用到的库文件链接起来，形成一个可以在操作系统中直接运行的可执行程序。（linux中的.o文件）

<font color=DeepSkyBlue>运行和调试</font>：我们接下来就可以执行程序了。如果出现问题我们可以进行调试debug。

<h2 id="5.cc中数组和链表的优缺点？">5.C/C++中数组和链表的优缺点？</h2>

数组和链表是C/C++中两种基本的数据结构，也是两个最常用的数据结构。

<font color=DeepSkyBlue>数组的特点</font>是在内存中，数组是一块连续的区域，并且数组需要预留空间。<font color=DeepSkyBlue>链表的特点</font>是在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续。链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址。每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据。

<font color=DeepSkyBlue>数组的优缺点</font>：

优点：查询效率高，时间复杂度可以达到O(1)。

缺点：新增和修改效率低，时间复杂度为O(N)；内存分配是连续的内存，扩容需要重新分配内存。

<font color=DeepSkyBlue>链表的优缺点</font>：

优点：新增和修改效率高，只需要修改指针指向即可，时间复杂度可以达到O(1)；内存分配不需要连续的内存，占用连续内存少。

缺点：链表查询效率低，需要从链表头依次查找，时间复杂度为O(N)。

<h2 id="6.cc中的new和malloc有什么区别？">6.C/C++中的new和malloc有什么区别？</h2>
  
new和malloc主要有以下三方面的区别：

1. malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。
  
2. malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
  
3. malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

<h2 id="7.cc中野指针的概念？">7.C/C++中野指针的概念？</h2>

野指针也叫空悬指针，不是指向null的指针，是未初始化或者未清零的指针。

**产生原因：**

1. 指针变量未及时初始化。

2. 指针free或delete之后没有及时置空。

**解决办法：**

1. 定义指针变量及时初始化活着置空。

2. 释放操作后立即置空。

<h2 id="8.cc中内存泄漏以及解决方法？">8.C/C++中内存泄漏以及解决方法？</h2>

内存泄漏是指己动态分配的堆内存由于某种原因导致程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

**解决方法：**

造成内存泄漏的主要原因是在使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存造成的。所以解决方法就是注意new/delete和malloc/free一定要配套使用。

<h2 id="9.cc中面向对象和面向过程的区别？">9.C/C++中面向对象和面向过程的区别？</h2>

面向对象（Object Oriented Programming，OOP）编程模型首先抽象出各种对象（各种类），并专注于对象与对象之间的交互，对象涉及的方法和属性都封装在对象内部。

面向对象的编程思想是一种依赖于类和对象概念的编程方式，一个形象的例子是将大象装进冰箱：

1. 冰箱是一个对象，大象也是一个对象。
2. 冰箱有自己的方法，打开、存储、关闭等；大象也有自己的方法，吃、走路等。
3. 冰箱有自己的属性：长、宽、高等；大象也有自己的属性：体重、高度、体积等。

面向过程（Procedure Oriented Programming，POP）编程模型是将问题分解成若干步骤（动作），每个步骤（动作）用一个函数来实现，在使用的时候，将数据传递给这些函数。

面向过程的编程思想通常采用自上而下、顺序执行的方式进行，一个形象的例子依旧是将大象装进冰箱：

1. 打开冰箱。
2. 把大象装进冰箱。
3. 关闭冰箱。

<h3 id="面向对象和面向过程的区别：">面向对象和面向过程的区别：</h3>

1. <font color=DeepSkyBlue>安全性角度</font>。面向对象比面向过程安全性更高，面向对象将数据访问隐藏在了类的成员函数中，而且类的成员变量和成员函数都有不同的访问属性；而面向过程并没有办法来隐藏程序数据。

2. <font color=DeepSkyBlue>程序设计角度</font>。面向过程通常将程序分为一个个的函数；而面向对象编程中通常使用一个个对象，函数通常是对象的一个方法。

3. <font color=DeepSkyBlue>逻辑过程角度</font>。面向过程通常采用自上而下的方法；而面向对象通常采用自下而上的方法。

4. <font color=DeepSkyBlue>程序扩展性角度</font>。面向对象编程更容易修改程序，更容易添加新功能。

<h2 id="10.cc中常用容器功能汇总">10.C/C++中常用容器功能汇总</h2>

<h3 id="vector（数组）">vector（数组）</h3>

vector是封装动态数组的顺序容器。

成员函数：
1. at():所需元素值的引用。
2. front():访问第一个元素（返回引用）。
3. back():访问最后一个元素（返回引用）。
4. beign():返回指向容器第一个元素的迭代器。
5. end():返回指向容器末尾段的迭代器。
6. empty():检查容器是否为空。
7. size():返回容器中的元素数。
8. capacity():返回当前存储空间能够容纳的元素数。
9.  clear():清除内容。
10. insert():插入元素。
11. erase():擦除元素。
12. push_back():将元素添加到容器末尾。
13. pop_back():移除末尾元素。
14. *max_element(v.begin(), v.end()):返回数组最大值。
15. *min_element(v.begin(), v.end()):返回数组最小值。

<h3 id="queue（队列）">queue（队列）</h3>

queue是容器适配器，他是FIFO（先进先出）的数据结构。

成员函数：
1. front():访问第一个元素（返回引用）。
2. back():访问最后一个元素（返回引用）。
3. empty():检查容器是否为空。
4. size():返回容器中的元素数。
5. push():向队列尾部插入元素。
6. pop():删除首个元素。

<h3 id="deque（双端队列）">deque（双端队列）</h3>

deque是有下标顺序容器，它允许在其首尾两段快速插入和删除。

成员函数：
1. front():访问第一个元素（返回引用）。
2. back():访问最后一个元素（返回引用）。
3. beign():返回指向容器第一个元素的迭代器。
4. end():返回指向容器末尾段的迭代器。
5. empty():检查容器是否为空。
6. size():返回容器中的元素数。
7. clear():	清除内容。
8. insert():插入元素。
9. erase():擦除元素。
10. push_back():将元素添加到容器末尾。
11. pop_back():移除末尾元素。
12. push_front():插入元素到容器起始位置。
13. pop_front():移除首元素。
14. at():所需元素值的引用。 

<h3 id="set（集合）">set（集合）</h3>
集合基于红黑树实现，有自动排序的功能，并且不能存放重复的元素。

成员函数：
1. begin()--返回指向第一个元素的迭代器。

 2. clear()--清除所有元素。

 3. count()--返回某个值元素的个数。

 4. empty()--如果集合为空，返回true。

 5. end()--返回指向最后一个元素的迭代器。

 6. erase()--删除集合中的元素。

 7. find()--返回一个指向被查找到元素的迭代器。

 8. insert()--在集合中插入元素。

 9. size()--集合中元素的数目。

<h3 id="unordered_set（无序集合）">unordered_set（无序集合）</h3>

无序集合基于哈希表实现，不能存放重复的元素。元素类型必须可以比较是否相等，因为这可以确定元素什么时候相等。

成员函数：
1. empty():检查容器是否为空。
2. size():返回容器中的元素数。
3. insert():插入元素。
4.  clear():清除内容。
5. count():返回匹配特定键的元素数量。
6. find():寻找带有特定键的元素。
7. erase()--删除集合中的元素。

<h3 id="unordered_map">unordered_map</h3>

unordered_map是关联容器，含有带唯一键的键-值对。

搜索、插入和元素移除拥有平均常数时间复杂度。

元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。

成员函数：
1. empty()：检查容器是否为空。
2. size()：返回可容纳的元素数。
3. insert():插入元素。
4.  clear():清除内容。
5. count():返回匹配特定键的元素数量。
6. find():寻找带有特定键的元素。
7. erase()--删除集合中的元素。
  
<h2 id="11.cc中指针和引用的区别">11.C/C++中指针和引用的区别</h2>

C语言的指针让我们拥有了直接操控内存的强大能力，而C++在指针基础上又给我们提供了另外一个强力武器$\to$引用。

首先我们来看一下C++中对象的定义：对象是指一块能存储数据并具有某种类型的内存空间。

一个对象a，它有值和地址&a。运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，我们通过该对象的地址，来访问存储空间中的值。

指针p也是对象，它同样有地址&p和存储的值p，只不过，<font color=DeepSkyBlue>p存储的是其他对象的地址</font>。如果我们要以p中存储的数据为地址，来访问对象的值，则要在p前加引用操作符$*$，即$*p$。

对象有常量（const）和变量之分，既然指针本身是对象，那么指针所存储的地址也有常量和变量之分，<font color=DeepSkyBlue>指针常量</font>是指，指针这个对象所存储的地址是不可改变的，而<font color=DeepSkyBlue>常量指针</font>的意思就是指向常量的指针。

我们可以<font color=DeepSkyBlue>把引用理解成变量的别名</font>。定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。<font color=DeepSkyBlue>计算机必须在声明引用r的同时就要对它初始化，并且r一经声明，就不可以再和其他对象绑定在一起了</font>。

实际上，我们也可以把引用看作是通过一个指针常量来实现的，指向的地址不变，地址里的内容可以改变。

接下来我们来看看指针和引用的**具体区别：**

1. 指针是一个新的变量，要占用存储空间，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量。而引用只是一个别名，还是变量本身，不占用具体存储空间，只有声明没有定义。对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的。
2. 引用只有一级，而指针可以有多级。
3. 指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作。引用传参的时候，传进来的就是变量本身，因此变量可以被修改。
4. 引用它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这样就提高了效率。
5. 引用必须初始化，而指针可以不初始化。

我们可以看下面的代码：

```cpp
int a,b,*p,&r=a;//正确
r=3;//正确：等价于a=3
int &rr;//出错：引用必须初始化
p=&a;//正确：p中存储a的地址，即p指向a
*p=4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
p=&b//正确：p可以多次赋值，p存储b的地址
```

“&”不仅能表示引用，还可以表示成地址，还有可以作为按位与运算符。这个要根据具体情况而定。比如上面的例子，等号左边的，被解释为引用，右边的被解释成取地址。

引用的操作加了比指针更多的限制条件，保证了整体代码的安全性和便捷性。引用的合理使用可以一定程度避免“指针满天飞”的情况，可以一定程度上提升程序鲁棒性。并且指针与引用底层实现都是一样的，不用担心两者的性能差距。
  
<h2 id="12.cc中宏定义的相关知识">12.C/C++中宏定义的相关知识</h2>

宏定义可以把一个名称指定成任何一个文本。在完成宏定义后，无论宏名称出现在源代码的何处，预处理器都会将其替换成指定的文本。

```
//define 宏名 文本
#define WeThinkIn 666688889999

//define 宏名(参数) 文本
#define R(a,b) (a/b)
//注：带参数的宏替换最好在表达式整体上加括号，避免结果受其他运算影响。
```

<font color=DeepSkyBlue>宏定义的优点</font>：

1. **方便程序修改**，如果一个常量在程序中大量使用，我们可以使用宏定义为其设置一个标识符。当我们想修改这个常量时，直接修改宏定义处即可，不必在程序中海量寻找所有相关位置。
2. **提高程序的运行效率**，使用带参数的宏定义可以完成函数的功能，但同时又比函数节省系统开销，提升程序运行效率。（无需调用函数这个流程）

<font color=DeepSkyBlue>宏定义和函数的区别</font>：

1. 宏在预处理阶段完成替换，之后替换的文本参与编译，相当于是恒等代换过程，运行时不存在函数调用，执行起来更快；而函数调用在运行时需要跳转到具体调用函数。
2. 宏定义没有返回值；函数调用具有返回值。
3. 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
4. 宏定义不是说明或者语句，结尾不用加分号。
5. 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用# undef命令；而函数作用域在函数调用处。
  
<h2 id="13.cc中typedef关键字的相关知识">13.C/C++中typedef关键字的相关知识</h2>

我们可以使用typedef关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称以及其他类型等名称。

在工业界中，我们一般在如下两个场景中会见到typedef的身影。

```
// 1.为基本数据类型定义新的类型名
typedef unsigned int WeThinkIn_int;
typedef char* WeThinkIn_point;
  
// 2.为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称
typedef struct target_Object
{
    int x;
    int y;
} WeThinkIn_Object;
```

<font color=DeepSkyBlue>typedef与宏定义的区别</font>：

1. 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
2. 宏替换发生在预处理阶段，属于文本恒等替换；typedef是编译中发挥作用。
3. 宏定义参数没有类型，不进行类型检查；typedef参数具有类型，需要检查类型。
4. 宏不是语句，不用在最后加分号；typedef是语句，要加分号标识结束。
5. 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

<h2 id="14.声明和定义的区别是什么？>14.声明和定义的区别是什么？</h2>
在C++中，声明（declaration）只是告诉编译器某个变量、函数或类型的名称及其类型信息，而定义（definition）则不仅包括声明，还为变量分配内存或为函数提供具体的实现代码。声明可以出现多次，但定义在一个作用域内只能出现一次。

<h2 id="15.i++和++i哪个执行效率高">15.i++和++i哪个执行效率高</h2>
在C++中，`++i`通常比`i++`执行效率更高。原因在于：
- `++i` 是前置递增，直接对变量进行加一操作并返回新值，不需要创建临时对象。
- `i++` 是后置递增，先保存变量的当前值，执行加一操作，然后返回旧值，因此可能需要创建临时对象以存储旧值，这在某些情况下会增加开销。
因此，`++i` 在大多数情况下比 `i++` 更高效。

<h2 id="16.数组名是什么？">16.数组名是什么？</h2>
在C++中，数组名是一个指向数组第一个元素的常量指针。它具有以下特点：
1. 指向数组的首元素：数组名表示数组在内存中的起始地址，即数组第一个元素的地址。
2. 不可修改：数组名是一个常量指针，它的值（即地址）不能被修改。
3. 隐式转换：在许多表达式中，数组名会隐式转换为指向数组第一个元素的指针。例如，在函数调用中传递数组时，实际上传递的是数组首元素的指针。
示例如下：
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // 数组名 arr 隐式转换为指向 arr[0] 的指针
在这个示例中，`arr` 是数组名，它等同于指向 `arr[0]` 的指针，因此 `ptr` 也指向 `arr[0]`。

<h2 id="17.C++中小数用二进制如何表示">17.C++中小数用二进制如何表示</h2>
小数在计算机中使用二进制表示时，采用的是浮点数表示法。这种表示法包括定点和浮点两种，但浮点数是更常用的方式。浮点数表示法类似于科学计数法，可以表示很大的范围和精度。

<h2 id="18.C++中什么是大端、小端？">18.C++中什么是大端、小端？</h2>

大端（Big-endian）和小端（Little-endian）是指计算机中存储多字节数据时字节的排列顺序：大端将高字节存储在低地址处，低字节存储在高地址处；小端则将低字节存储在低地址处，高字节存储在高地址处。

<h2 id="19.C++里有哪些类型转换运算符？">19.C++里有哪些类型转换运算符？</h2>
C++里有四种类型转换运算符：`static_cast`用于一般类型转换，`dynamic_cast`用于运行时类型安全的多态类型转换，`const_cast`用于修改对象的常量性，`reinterpret_cast`用于低级别的、几乎不受限制的类型转换。这些运算符提供了比传统C风格类型转换更安全和明确的转换方式。

<h2 id="20.C++中赋值与初始化的区别">20.C++中赋值与初始化的区别</h2>
赋值是给已存在的对象重新赋值，而初始化是创建对象时赋予其初始值。赋值操作发生在对象已经存在之后，而初始化操作在对象创建时就完成了。初始化通常在对象声明时通过构造函数完成，而赋值则可以在对象生命周期的任何时刻进行。
const成员和引用是如何初始化的
`const`成员和引用必须通过初始化列表在对象构造函数中进行初始化，因为它们在对象创建后无法被赋值或修改。

<h2 id="21.C++中异常处理机制">21.C++中异常处理机制</h2>
C++异常处理机制通过`try`、`throw`和`catch`关键字实现，`try`块中包含可能引发异常的代码，`throw`用于抛出异常，`catch`块捕获并处理异常，提供了一种结构化的方法来处理运行时错误并确保程序的健壮性。

<h2 id="22.C++中new、delete、malloc、free关系">22.C++中new、delete、malloc、free关系</h2>
`new`和`delete`是C++中用于动态内存分配和释放的运算符。`new`运算符在堆上分配内存并调用构造函数来初始化对象，而`delete`运算符则释放内存并调用析构函数来清理对象。它们提供了类型安全的内存管理方式，适合用于C++中的面向对象编程。

`malloc`和`free`是C语言中用于动态内存分配和释放的函数。`malloc`函数分配指定字节的内存块，但不调用构造函数进行初始化，而`free`函数释放之前使用`malloc`分配的内存块，但不调用析构函数进行清理。它们不具有类型安全性，因此在C++中通常建议使用`new`和`delete`替代。

<h2 id="23.介绍一下register关键字">23.介绍一下register关键字</h2>
`register`关键字用于建议编译器将变量存储在寄存器中以提高访问速度，但现代编译器通常会自行优化变量的存储位置，因此这个关键字的实际影响较小且在C++17中已被弃用。

<h2 id="24.介绍一下const关键字">24.介绍一下const关键字</h2>
`const`关键字用于声明不可修改的变量、指针或成员函数，确保其值或状态在程序运行过程中保持不变，从而增加代码的安全性和可读性。

<h2 id="25.C++中介绍一下delete与delete[]区别">25.C++中介绍一下delete与 delete []区别</h2>
`delete`用于释放单个对象的内存并调用其析构函数，而`delete[]`用于释放数组对象的内存并调用每个元素的析构函数，使用不当会导致未定义行为和潜在的内存泄漏或崩溃。
<h2 id="26.介绍一下newoperator和operatornew的区别">26.介绍一下new operator和operator new 的区别</h2>
`new` operator是C++中的关键字，用于分配内存并调用对象的构造函数，而`operator new`是一个函数，类似于`malloc`，只负责分配内存，不调用构造函数，允许用户自定义内存分配的行为。

<h2 id="27.介绍一下external关键字]">27.介绍一下external关键字]</h2>
`extern`关键字用于声明变量或函数在其他文件中定义，以实现跨文件的访问和共享，避免重复定义，通常用于变量的声明而不是定义，确保链接时能够找到正确的符号。

<h2 id="28.介绍一下volatile关键字]">28.介绍一下volatile关键字]</h2>
`volatile`关键字用于指示编译器一个变量的值可能会被程序外部因素（如硬件或另一个线程）修改，从而阻止编译器对该变量进行优化，确保每次访问都从内存中读取，以保证程序能够正确处理这些变化。

<h2 id="29.介绍一下dynamic在什么时候使用">29.介绍一下dynamic在什么时候使用</h2>
`dynamic_cast`在C++中用于运行时类型安全转换，特别是用于在继承层次结构中向下转换指针或引用，确保转换的合法性，并在转换失败时返回`nullptr`（对于指针）或抛出`std::bad_cast`异常（对于引用）。

<h2 id="30.介绍一下vector优缺点">30.介绍一下vector优缺点</h2>
`std::vector`是C++标准库中的动态数组，具有自动管理内存、支持随机访问、高效插入和删除尾部元素的优点，但在中间位置插入或删除元素时性能较差，并且在重新分配内存时可能导致迭代器失效和性能开销。

<h2 id="31.介绍一下list优缺点">31.介绍一下list优缺点</h2>
`std::list`是C++标准库中的双向链表，具有快速的插入和删除操作，不会导致迭代器失效的优点，但不支持随机访问，且遍历和查找元素的性能相对较差。

<h2 id="32.介绍一下deque优缺点">32.介绍一下deque优缺点</h2>
`std::deque`是C++标准库中的双端队列，支持高效的双端插入和删除操作，允许快速随机访问，适合需要在两端频繁操作的场景，但在中间位置插入和删除元素时性能较差，且与`std::vector`相比，内存使用效率稍低。

<h2 id="33.介绍一下map&set优缺点">33.介绍一下map&set优缺点</h2>
`std::map`和`std::set`是C++标准库中的关联容器，提供高效的键值对存储（`map`）和唯一元素存储（`set`）以及自动排序功能，具有O(log n)的查找、插入和删除性能，但由于底层使用红黑树实现，较`unordered_map`和`unordered_set`（基于哈希表）在特定场景下的访问速度稍慢。

<h2 id="34.介绍一下mutable关键字的作用">34.介绍一下mutable关键字的作用</h2>
`mutable`关键字用于允许对象的成员变量在`const`成员函数中被修改，通常用于需要在逻辑上视为常量但在实现上可能需要改变状态的成员变量，例如缓存或统计信息。

<h2 id="35.什么时候用static">35.什么时候用static</h2>
`static`关键字在C++中用于声明静态变量或函数，其作用包括在局部变量中维持变量的生命周期为整个程序运行期间，在类中共享所有实例之间的成员变量或函数，以及在全局作用域中限制变量或函数的可见性仅在当前编译单元内。

<h2 id="36.容器选择的原则">36.容器选择的原则</h2>
容器选择的原则是根据应用场景的需求来选择适当的容器，考虑因素包括元素的访问方式（顺序访问、随机访问）、插入和删除操作的频率与位置（头部、尾部、中间）、内存使用和迭代器的有效性，例如，选择`vector`用于频繁随机访问，选择`list`用于频繁插入和删除操作，选择`map`或`set`用于需要快速查找和有序存储。

<h2 id="37.什么是迭代器，有哪几种迭代器]">37.什么是迭代器，有哪几种迭代器]</h2>
迭代器是用于遍历容器元素的对象或指针，提供一致的接口来访问容器元素，C++中主要有五种迭代器：输入迭代器（Input Iterator）、输出迭代器（Output Iterator）、前向迭代器（Forward Iterator）、双向迭代器（Bidirectional Iterator）和随机访问迭代器（Random Access Iterator），它们分别适用于不同的遍历需求和容器类型。

<h2 id="38.什么是指针数组、什么是数组指针]">38.什么是指针数组、什么是数组指针]</h2>
指针数组是一个数组，数组中的每个元素都是指针（例如 `int* arr[10]` 是一个包含10个指向整数的指针的数组）；数组指针是一个指针，指向一个数组的首地址（例如 `int (*ptr)[10]` 是一个指向包含10个整数的数组的指针）。

<h2 id="39.指针与数组的区别">39.指针与数组的区别</h2>
指针是一个变量，用于存储内存地址，可以动态指向不同位置，而数组是一块连续的内存区域，存储一组相同类型的元素，数组名在大多数情况下会被隐式转换为指向其第一个元素的指针，但数组的大小和位置在声明时确定且固定。

<h2 id="40.引用和指针的区别">40.引用和指针的区别</h2>
引用是一个变量的别名，在声明时必须初始化且不能改变引用对象，而指针是一个变量，存储另一个变量的地址，可以在任何时候改变指向不同的对象并支持算术操作。

<h2 id="41.什么是内联函数">41.什么是内联函数</h2>
内联函数是使用`inline`关键字修饰的函数，建议编译器在调用该函数时将其函数体展开以减少函数调用开销，适用于代码量小且频繁调用的函数，但编译器可能会根据实际情况选择是否真正内联。

<h2 id="39.指针与数组的区别">39.指针与数组的区别</h2>
宏函数使用`#define`预处理指令定义，在编译前进行文本替换，没有类型检查和作用域控制，易出错；自定义函数在编译时进行处理，支持类型检查、作用域控制和更好的调试，提供了更安全和灵活的功能定义方式。

<h2 id="40.引用和指针的区别">40.引用和指针的区别</h2>
函数调用的步骤包括将实参传递给形参，保存当前的执行状态（如返回地址），然后跳转到被调用函数的地址执行函数体代码，函数执行完毕后将返回值传递回调用者，恢复之前的执行状态并继续执行调用点之后的代码。

<h2 id="41.什么是内联函数">41.什么是内联函数</h2>
纯虚函数是未提供实现的虚函数，使用`= 0`语法声明，抽象类是包含至少一个纯虚函数的类，不能直接实例化，主要用于定义接口，由其派生类提供具体实现。

<h2 id="42.宏函数和自定义函数的区别">42.宏函数和自定义函数的区别</h2>
宏函数通过`#define`定义，进行简单的文本替换，没有类型检查和作用域控制，可能导致难以调试的错误；自定义函数则在编译时处理，支持类型检查和作用域控制，提供更安全和可靠的代码执行方式。

<h2 id="43.函数调用的步骤">43.函数调用的步骤</h2>
函数重载要求同一作用域内的多个函数具有相同的名称，但参数列表必须不同，包括参数的数量、类型或顺序，以便编译器能够区分并正确调用相应的函数版本。

<h2 id="44.什么是纯虚函数抽象类">44.什么是纯虚函数抽象类</h2>
构造函数是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象的成员变量，不能有返回类型（包括void），可以重载以提供不同的初始化方式，并且可以有默认参数，但不能被显式调用或继承。

<h2 id="45.函数重载条件">45.函数重载条件</h2>
友元函数是被声明为某个类的友元的函数，允许它访问该类的私有和保护成员，尽管它本身并不是该类的成员，通常用于实现需要直接访问对象内部实现细节的功能，如重载运算符或实现外部辅助函数。

<h2 id="46.构造函数的特点？">46.构造函数的特点</h2>
构造函数的作用是初始化对象的成员变量，并执行任何必要的设置操作，在对象创建时自动调用，确保对象在使用前处于有效状态，并可以通过重载提供多种初始化方式。

<h2 id="47.什么是析构函数、析构函数的作用">47.什么是析构函数、析构函数的作用</h2>
析构函数是类的特殊成员函数，与类同名但前面带有波浪号`~`，在对象生命周期结束时自动调用，其作用是执行清理操作，如释放动态分配的内存、关闭文件或释放其他资源，确保对象在销毁前完成所有必要的清理工作。

<h2 id="48.C++定义常量两种方式是什么？">48.C++定义常量两种方式是什么？</h2>
    #define 宏常量： #define 常量名 常量值
    通常在文件上方定义，表示一个常量
    const修饰的变量 const 数据类型 常量名 = 常量值
    通常在变量定义前加关键字const，修饰该变量为常量，不可修改
    
<h2 id="49.重载函数是否能够通过函数返回值的类型不同来区分？">49.重载函数是否能够通过函数返回值的类型不同来区分？</h2>
不能。重载函数不能仅仅通过函数返回值类型的不同来区分。C++的函数重载是基于参数列表的不同（包括参数的数量、类型或顺序）来实现的，编译器无法仅根据返回类型来确定。

<h2 id="50.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？">50.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？</h2>
首先，`extern` 是C/C++语言中用于指定函数和全局变量作用范围的关键字。它告诉编译器，这些声明的函数和变量可以在当前模块或其它模块中使用。

通常在模块的头文件中，对本模块提供给其它模块引用的函数和全局变量使用`extern`关键字进行声明。`extern "C"` 是一种连接声明(linkage declaration)，被 `extern "C"` 修饰的变量和函数按照C语言的方式进行编译和连接。作为面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：`void foo(int x, int y);` 该函数被C编译器编译后在符号库中的名字为 `_foo`，而C++编译器则会产生像 `_foo_int_int` 之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++通过这种机制实现函数重载。

总结来说，`extern "C"` 声明的主要目的是解决名字匹配问题，从而实现C++与C的混合编程。

<h2 id="51.头文件中的ifndef/define/endif有什么作用？">51.头文件中的ifndef/define/endif有什么作用？</h2>
在C++头文件中，#ifndef、#define 和 #endif 的组合用于防止头文件被多次包含。这种机制称为“头文件保护”或“包含保护”。它的主要作用是避免重复定义导致的编译错误。下面是每个部分的详细作用：
    #ifndef（如果未定义）：
    这个指令用于检查一个特定的宏是否未被定义。如果未定义，则继续处理后续的代码。
    #define（定义）：
    这个指令用于定义一个宏。通过定义一个唯一的标识符，可以确保在其他地方包含同一个头文件时，这个标识符已经定义，从而避免重复包含。
    #endif（结束条件编译）：
    这个指令标志着条件编译的结束。如果前面的条件（即 #ifndef）为真，编译器会处理 #endif 之前的所有代码。
<h2 id="52.＃include<file.h>与＃include"file.h"的区别？">49.重载函数是否能够通过函数返回值的类型不同来区分？</h2>
在C/C++中，#include <file.h> 和 #include "file.h" 都用于包含头文件，但它们有一些重要的区别：

    #include <file.h>：
        这种方式主要用于包含标准库头文件。
        编译器会在标准系统目录中查找指定的头文件。
        系统目录通常包括编译器默认的头文件路径以及在编译器配置中指定的路径。

    #include "file.h"：
        这种方式主要用于包含用户自定义的头文件。
        编译器首先在当前源文件所在的目录中查找指定的头文件。
        如果在当前目录中找不到，编译器会在标准系统目录中继续查找。
        可以用于包含项目中的其他模块或文件。

总体来说：
使用 #include "file.h" 可以确保编译器优先查找当前项目目录，这在开发过程中非常有用，尤其是当你有自定义的头文件时。
使用 #include <file.h> 可以避免与标准库头文件冲突，并且编译器在查找标准库头文件时通常会进行一些优化。

<h2 id="53.介绍一下C/C++各自的特点？">53.介绍一下C/C++各自的特点？</h2>
C语言是一种结构化语言，侧重于过程编程，基于算法和数据结构，关注的是如何通过过程或函数从输入得到输出。C++则是一种面向对象的语言，基于类、对象和继承，关注的是如何构建一个对象模型，使其能够与所处理的问题相适应，并通过获取对象的状态信息来实现输出或过程控制。


<h2 id="54.介绍一下const 用途？">54.介绍一下const 用途？</h2>

在C和C++中，`const` 关键字用于定义常量和限制变量的可修改性。它的主要用途如下：
1. **定义常量**：
   - 使用 `const` 关键字可以定义不可修改的变量，这样可以避免在程序中意外改变其值。
   ```cpp
   const int MAX_SIZE = 100;
   ```
2. **保护函数参数**：
   - 在函数参数中使用 `const` 可以防止在函数内部修改传入的参数值，确保参数在函数内部是只读的。
   ```cpp
   void printArray(const int* array, int size);
   ```
3. **修饰成员函数**：
   - 在C++中，`const` 可以用来修饰成员函数，表示该成员函数不会修改对象的状态。即，该成员函数不允许修改类的成员变量。
   ```cpp
   class MyClass {
   public:
       int getValue() const;
   private:
       int value;
   };
   ```
4. **指针和引用**：
   - `const` 可以用于修饰指针和引用，分别表示指针指向的内容不可变或指针本身不可变。
   ```cpp
   const int* ptr1;   // 指向常量的指针，指针指向的内容不可变
   int* const ptr2;   // 常量指针，指针本身不可变
   const int* const ptr3; // 指向常量的常量指针，指针本身和指针指向的内容都不可变
   ```
5. **常量引用**：
   - 在C++中，常量引用可以用于函数参数，避免拷贝大的对象，同时防止修改对象。
   ```cpp
   void display(const std::string& str);
   ```
### 示例代码
#### 定义常量
```cpp
const double PI = 3.14159;
```
#### 函数参数

```cpp
void displayArray(const int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
}
```
#### 修饰成员函数

```cpp
class Circle {
public:
    Circle(double r) : radius(r) {}
    double getArea() const {
        return 3.14159 * radius * radius;
    }
private:
    double radius;
};
```
#### 指针和引用
```cpp
void example() {
    int value = 10;
    const int* ptr1 = &value;   // ptr1指向的内容不能被改变
    int* const ptr2 = &value;   // ptr2不能指向其他地址
    const int* const ptr3 = &value; // ptr3的指向和内容都不能被改变
}
```
通过使用 `const`，可以提高代码的安全性和可读性，防止意外修改数据，确保函数行为的一致性。

<h2 id="55.const和#define有什么区别？">55.const和#define有什么区别？</h2>
`const` 和 `#define` 在C和C++中都有定义常量的作用，但它们之间有一些重要的区别：

1. **类型检查**：
   - `const` 变量具有类型，编译器会进行类型检查，确保类型安全。
   - `#define` 定义的宏常量没有类型，编译器不进行类型检查，这可能会导致一些意想不到的错误。

2. **作用域**：
   - `const` 常量具有作用域，可以是局部的（如在函数内定义）或全局的（如在文件顶层定义），并且遵循C/C++的作用域规则。
   - `#define` 定义的宏常量没有作用域概念，它们在预处理阶段被简单地文本替换，作用于整个文件。

3. **存储方式**：
   - `const` 常量在内存中有实际的存储位置，可以取地址。
   - `#define` 定义的宏常量在编译后没有存储位置，只是简单的文本替换，不能取地址。

4. **调试支持**：
   - `const` 常量在调试时可以查看其值，因为它们在内存中有实际存储位置。
   - `#define` 宏常量在调试时难以查看，因为它们只是文本替换，没有实际存储位置。

5. **语法和使用**：
   - `const` 常量需要指定类型，并且遵循变量的声明和初始化规则。
   - `#define` 宏常量是预处理指令，不需要类型和分号，只需简单的文本替换。

### 示例

#### 使用 `const` 定义常量

```cpp
const int MAX_SIZE = 100;

void example() {
    const double PI = 3.14159;
    // MAX_SIZE 和 PI 都具有类型和作用域，可以进行类型检查和调试
}
```

#### 使用 `#define` 定义宏常量

```cpp
#define MAX_SIZE 100

void example() {
    #define PI 3.14159
    // MAX_SIZE 和 PI 都是简单的文本替换，没有类型检查和作用域
}
```

### 详细示例

#### 类型检查

```cpp
const int MAX_SIZE = 100;
float size = MAX_SIZE; // 类型安全，编译器会检查类型

#define MAX_SIZE 100
float size = MAX_SIZE; // 没有类型检查，编译器不会报错
```

#### 调试支持

```cpp
const int MAX_SIZE = 100;

#define MAX_SIZE 100

void example() {
    const int x = MAX_SIZE; // 可以在调试时查看 x 的值

    int y = MAX_SIZE; // 编译后，y = 100，没有实际存储位置，难以调试
}
```

#### 作用域

```cpp
void example() {
    const int local_const = 50; // 只在函数内有效
    #define LOCAL_MACRO 50 // 在整个文件内有效
}
```

#### 取地址

```cpp
const int MAX_SIZE = 100;
const int* ptr = &MAX_SIZE; // 可以取地址

#define MAX_SIZE 100
// int* ptr = &MAX_SIZE; // 错误，无法取地址
```

综上所述，`const` 提供了类型安全、作用域管理和调试支持，而 `#define` 则是简单的文本替换，适用于定义无需类型检查的常量。

<h2 id="55.sizeof与strlen的区别？">55.sizeof与strlen的区别？</h2>
`sizeof` 和 `strlen` 都用于获取数据大小，但它们有不同的用途和工作方式。下面是它们之间的区别：

### `sizeof` 操作符

1. **用途**：
   - 用于确定变量、数据类型或对象的大小（以字节为单位）。

2. **工作方式**：
   - 在编译时计算出其操作数的大小。

3. **适用对象**：
   - 可以用于基本数据类型、数组、结构体、类等。

4. **返回值类型**：
   - 返回的是 `size_t` 类型。

5. **示例**：
   ```cpp
   int a = 10;
   int arr[10];
   struct MyStruct {
       int x;
       double y;
   };

   size_t size_a = sizeof(a);          // 计算int类型变量a的大小，通常是4字节
   size_t size_arr = sizeof(arr);      // 计算数组arr的总大小，10 * sizeof(int)
   size_t size_struct = sizeof(MyStruct); // 计算结构体MyStruct的大小
   ```

### `strlen` 函数

1. **用途**：
   - 用于计算以 `null` 结尾的字符串的长度（不包括末尾的 `null` 字符）。

2. **工作方式**：
   - 在运行时遍历字符串直到找到 `null` 字符（`'\0'`），计算其长度。

3. **适用对象**：
   - 仅用于以 `null` 结尾的字符数组或字符串常量。

4. **返回值类型**：
   - 返回的是 `size_t` 类型。

5. **示例**：
   ```cpp
   const char* str = "Hello, world!";
   size_t length = strlen(str);  // 计算字符串的长度，不包括末尾的'\0'，结果是13
   ```

### 详细示例

#### 使用 `sizeof` 计算类型和数组大小

```cpp
#include <iostream>

int main() {
    int num = 42;
    int arr[10];
    char str[] = "Hello";

    std::cout << "Size of int: " << sizeof(int) << std::endl;       // 4（通常）
    std::cout << "Size of num: " << sizeof(num) << std::endl;       // 4（通常）
    std::cout << "Size of arr: " << sizeof(arr) << std::endl;       // 40（10 * 4）
    std::cout << "Size of str: " << sizeof(str) << std::endl;       // 6（包括'\0'）
    
    return 0;
}
```

#### 使用 `strlen` 计算字符串长度

```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* str1 = "Hello, world!";
    char str2[] = "Hello";

    std::cout << "Length of str1: " << strlen(str1) << std::endl;   // 13
    std::cout << "Length of str2: " << strlen(str2) << std::endl;   // 5
    
    return 0;
}
```

### 总结

- `sizeof` 用于计算变量、类型或对象的大小，在编译时确定，适用于任何类型。
- `strlen` 用于计算以 `null` 结尾的字符串长度，在运行时确定，只适用于以 `null` 结尾的字符数组或字符串常量。

<h2 id="56.什么是多态？多态有什么作用？">56.什么是多态？多态有什么作用？</h2>
多态是C++中的一种面向对象编程特性，它允许通过基类指针或引用调用派生类中的重写函数，实现同一操作在不同对象上的不同表现。多态的作用在于提高代码的灵活性和可扩展性，使得程序能够处理不同类型的对象而不需要知道它们的具体类型，从而实现更好的代码复用和系统扩展。
<h2 id="57.重载和覆盖有什么区别？">57.重载和覆盖有什么区别？</h2>
重载（Overloading）和覆盖（Overriding）是C++中的两种多态机制。重载指的是在同一个作用域内定义多个同名函数，但参数列表不同（参数类型、数量或顺序），以支持不同的函数调用；而覆盖指的是在派生类中重新定义基类中已经存在的虚函数，通过匹配函数签名和使用虚函数机制，改变或扩展基类函数的行为。重载是在编译时选择适当的函数，覆盖是在运行时决定调用哪个函数。

<h2 id="58.空指针和悬垂指针的区别？">58.空指针和悬垂指针的区别？</h2>
空指针和悬垂指针在C/C++中分别代表不同的指针问题：

- **空指针（NULL Pointer）**：是一个指向无效或未分配内存的指针，通常用于表示指针当前不指向任何有效对象。空指针的值是 `NULL`（在C++中通常使用 `nullptr`）。空指针的主要用途是作为初始化值或检查指针是否有效的标志。

  ```cpp
  int* ptr = nullptr; // 空指针
  ```

- **悬垂指针（Dangling Pointer）**：是一个指向已经被释放或不再有效的内存区域的指针。这种指针指向的内存区域可能已经被重新分配或销毁，使用悬垂指针会导致未定义行为或程序崩溃。悬垂指针通常是由于内存释放后没有将指针设置为 `NULL` 或 `nullptr` 造成的。

  ```cpp
  int* ptr = new int(10); // 动态分配内存
  delete ptr;             // 释放内存
  // ptr 现在是悬垂指针
  ```

总结：空指针表示指针当前不指向任何有效对象，而悬垂指针指向已经无效的内存区域，前者用于初始化和检查，后者则可能导致严重的程序错误。

<h2 id="59.什么是智能指针？">59.什么是智能指针？</h2>
智能指针是C++标准库中的类模板，用于自动管理动态分配内存的生命周期，从而减少内存泄漏和悬垂指针等问题。通过封装原始指针，智能指针提供了自动释放内存的功能，并支持不同的拥有权语义，如独占（`std::unique_ptr`）、共享（`std::shared_ptr`）和弱引用（`std::weak_ptr`）。

<h2 id="60.C++空类默认有哪些成员函数？">60.C++空类默认有哪些成员函数？</h2>
在C++中，即使一个类没有显式定义任何成员函数，编译器也会自动生成默认的构造函数、析构函数、复制构造函数和赋值运算符。这些默认成员函数使得空类可以被创建、销毁，并支持对象的复制和赋值操作。例如，空类 `class Empty {};` 会自动获得这些默认成员函数的实现，除非你显式地定义或删除它们。

<h2 id="61.C++哪一种成员变量可以在一个类的实例之间共享？">61.C++哪一种成员变量可以在一个类的实例之间共享？</h2>
在C++中，`static` 成员变量可以在一个类的所有实例之间共享。`static` 成员变量属于类本身，而不是某个特定的对象，因此所有类的实例共享同一个 `static` 成员变量的值。

### 特点
- **共享**：所有对象实例共享同一个 `static` 成员变量。
- **类作用域**：它的生命周期与类的生命周期相同，而不是与对象的生命周期相同。
- **访问**：可以通过类名直接访问，也可以通过对象实例访问，但通常通过类名来访问更为明确。

### 示例代码

```cpp
#include <iostream>

class MyClass {
public:
    static int sharedValue; // 静态成员变量声明
    void printValue() const {
        std::cout << "Shared value: " << sharedValue << std::endl;
    }
};

// 静态成员变量的定义
int MyClass::sharedValue = 0;

int main() {
    MyClass obj1;
    MyClass obj2;

    obj1.sharedValue = 10; // 修改静态成员变量

    obj1.printValue(); // 输出: Shared value: 10
    obj2.printValue(); // 输出: Shared value: 10

    return 0;
}
```

在这个示例中，`sharedValue` 是一个静态成员变量，它的值在所有 `MyClass` 类的实例之间共享。无论通过哪个实例访问或修改 `sharedValue`，所有实例都会看到相同的值。

<h2 id="62.继承层次中，为什么基类析构函数是虚函数？">62.继承层次中，为什么基类析构函数是虚函数？</h2>
在继承层次中，基类的析构函数应该是虚函数，以确保在通过基类指针删除派生类对象时，能够正确调用派生类的析构函数，从而避免资源泄漏和未定义行为。虚析构函数使得 C++ 的动态绑定机制能够在删除对象时正确地调用实际的派生类析构函数，从而完成派生类特有资源的释放。





