- [1.C++中什么是大端、小端？](#1.C++中什么是大端、小端？)
- [2.重载函数是否能够通过函数返回值的类型不同来区分？](#2.重载函数是否能够通过函数返回值的类型不同来区分？)
- [3.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”](#3.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？)
- [4.进程间如何通信？](#4.进程间如何通信？)
- [5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？](#5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？)
- [6. map的底层原理是什么？](#6.map的底层原理是什么？)
- [7. socket与其他通信方式有什么不同？](#7.socket与其他通信方式有什么不同？)
- [8.TCP和UDP的区别是什么，TCP什么时候会重传？](#8.TCP和UDP的区别是什么，TCP什么时候会重传？)
- [9. map和unordered_map了解吗？](#9.map和unordered_map了解吗？)
- [10.hashmap和map的区别，底层数据结构算法是什么？](#10.hashmap和map的区别，底层数据结构算法是什么？)
- [11.介绍一下红黑树？](#11.介绍一下红黑树？)
- [12.介绍一下hash](#12.介绍一下hash)
- [13.介绍一下二叉树？](#13.介绍一下二叉树？)
- [14.编程实现LRU](#14.编程实现LRU)
- [15.编程实现memcopy](#15.编程实现memcopy)


<h2 id="1.C++中什么是大端、小端？">1.C++中什么是大端、小端？</h2>

大端（Big-endian）和小端（Little-endian）是指计算机中存储多字节数据时字节的排列顺序：大端将高字节存储在低地址处，低字节存储在高地址处；小端则将低字节存储在低地址处，高字节存储在高地址处。

<h2 id="2.重载函数是否能够通过函数返回值的类型不同来区分？">2.重载函数是否能够通过函数返回值的类型不同来区分？</h2>
不能。重载函数不能仅仅通过函数返回值类型的不同来区分。C++的函数重载是基于参数列表的不同（包括参数的数量、类型或顺序）来实现的，编译器无法仅根据返回类型来确定。

<h2 id="3.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？">3.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？</h2>
首先，`extern` 是C/C++语言中用于指定函数和全局变量作用范围的关键字。它告诉编译器，这些声明的函数和变量可以在当前模块或其它模块中使用。

通常在模块的头文件中，对本模块提供给其它模块引用的函数和全局变量使用`extern`关键字进行声明。`extern "C"` 是一种连接声明(linkage declaration)，被 `extern "C"` 修饰的变量和函数按照C语言的方式进行编译和连接。作为面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：`void foo(int x, int y);` 该函数被C编译器编译后在符号库中的名字为 `_foo`，而C++编译器则会产生像 `_foo_int_int` 之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++通过这种机制实现函数重载。

总结来说，`extern "C"` 声明的主要目的是解决名字匹配问题，从而实现C++与C的混合编程。

<h2 id="4.进程间如何通信？">4.进程间如何通信？</h2>
管道：允许一个进程和另一个与它有共同祖先的进程之间进行通信。
消息队列：消息的链表，存储在内核中，由进程间发送接收消息。
共享内存：允许多个进程访问同一块内存空间，是最快的IPC方式。
信号量：主要用于解决进程间的同步问题。
套接字：适用于不同机器间的进程通信。
信号：用于通知接收进程某个事件已经发生。

<h2 id="5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？">5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？</h2>
（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。
（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；
（3）线程产生的速度快，线程间通信快、切换快；
（4）线程的资源利用率比较好；
（5）线程使用公共变量或者资源时需要同步机制。

<h2 id="6.map的底层原理是什么？">6.map的底层原理是什么？</h2>

map的底层原理:
map的底层是基于红黑树实现的。
红黑树是一种自平衡二叉搜索树，它能保证基本操作（如查找、插入、删除）的时间复杂度为O(log n)，确保树的高度保持在对数级别。
通过键值对自动排序和高效操作维持了其数据结构的稳定性和效率。

<h2 id="7.socket与其他通信方式有什么不同？">7.socket与其他通信方式有什么不同？</h2>

Socket 可以实现不同主机间的进程通信，适用于网络中跨操作系统通信。
Socket 通常支持全双工通信，即同一时间可以进行数据的双向传输。
Socket 支持面向连接（如TCP协议）和无连接（如UDP协议）的通信方式。
使用 Socket 进行通信需要创建、配置、使用和关闭套接字，比其他通信方式如管道和信号等有更明确的使用流程。

<h2 id="8.TCP和UDP的区别是什么，TCP什么时候会重传？">8.TCP和UDP的区别是什么，TCP什么时候会重传？</h2>

连接：
TCP是面向连接的协议，进行数据传输前需要建立连接。
UDP是无连接的协议，不需要建立连接就可以直接发送数据。
可靠性：
TCP提供可靠的数据传输，确保数据完整性和顺序。
UDP提供不可靠的数据传输，可能出现丢包，不保证数据顺序。
速度：
TCP相对较慢，因为它需要确认机制和错误校正。
UDP传输速度更快，没有确认机制，适用于对速度要求高的场合。
数据流：
TCP提供字节流服务，通过数据流的方式发送数据。
UDP以数据报文的形式发送信息，发送独立的消息。

超时重传：如果发送方在设定的超时时间内没有收到接收方的确认（ACK），它会重传那个数据段。 快速重传：如果发送方收到三个或更多的冗余ACK（即对同一个数据段的连续确认），它会在没有等待超时的情况下立即重传那个被认为丢失的数据段。 接收方提示：接收方可以通过ACK中的SACK选项（选择确认），明确指出哪些数据段已收到，哪些未收到，促使发送方仅重传未被确认接收的数据段。

<h2 id="9.map和unordered_map了解吗？">9.map和unordered_map了解吗？</h2>
map：
底层实现是红黑树，一个自平衡的二叉搜索树。
元素根据键值自动排序。
插入、删除和查找操作的时间复杂度为O(log n)。

unordered_map：
底层实现是哈希表。
元素不会自动排序。
平均情况下插入、删除和查找操作的时间复杂度为O(1)，最坏情况下为O(n)。


<h2 id="10.hashmap和map的区别，底层数据结构算法是什么？">10.hashmap和map的区别，底层数据结构算法是什么？</h2>

在 C++ 中，虽然没有直接对应 HashMap 和 Map 的标准库接口，但可通过 unordered_map 和 map 实现类似功能。二者区别在于：
    底层实现不同：unordered_map 是哈希表实现，map 是红黑树实现。
    元素顺序不同：unordered_map 不保证元素顺序，map 按照键的自然顺序排序。
    对空值的处理不同：从 C++11 开始，unordered_map 允许键和值为 null，map 不允许键为空。
底层数据结构算法方面：
    unordered_map 利用散列函数将键映射到存储桶，采用链地址法解决哈希冲突。
    map 以红黑树为底层数据结构，保证元素有序，插入、删除和查找操作的时间复杂度为 O (log N)。


<h2 id="11.介绍一下红黑树">11.介绍一下红黑树</h2>

红黑树是一种自平衡二叉搜索树，在插入和删除操作后会通过调整节点颜色与进行旋转来维持平衡。其特点如下：
- 节点颜色为红或黑。
- 根节点为黑色。
- 叶子节点（NULL 节点）皆为黑色。
- 红色节点的两个子节点必为黑色，不可出现连续红色节点。
- 从任一节点到其后代叶子节点的简单路径上，黑色节点数量一致，空子树到后代叶子节点的简单路径也如此。

凭借这些规则，红黑树可保持良好的平衡性质，在最坏情况下能实现 O(logN)时间复杂度的搜索、插入和删除操作。

对于插入操作，先将新节点设为红色，若违反红黑树性质 4 则进行旋转和变换修正，最后把根节点设为黑色。删除操作时，若被删除节点有两个非空子节点，需找到其后继节点（右子树最小值或左子树最大值），用后继节点替换原节点后再删除后继节点；若被删除节点只有一个子节点或无子节点则直接删除。删除后若违反性质 4，同样要进行一系列旋转和变换来修正。
    
    
    
    
<h2 id="12.介绍一下hash">12.介绍一下hash</h2>

哈希（Hash）是将任意长度的输入数据通过哈希函数

（Hash Function）转换为固定长度的输出值的过程。哈希函数将输入数据映射到一个固定大小的哈希值，通常表示为一串数字或字母。

哈希函数具有以下特点：

    输入相同的数据始终会得到相同的哈希值。
    不同的输入数据产生不同的哈希值。
    哈希值长度固定，无论输入数据多长，输出结果都是相同长度。

在计算机领域，哈希常被用于以下方面：

    数据存储和索引：使用哈希表作为底层数据结构，通过键-值对存储和快速查找

数据。
密码学：密码验证、数字签名

    、消息摘要等应用需要使用安全的哈希函数。
    数据完整性校验：通过比较两个文件或消息的哈希值来判断是否一致。
    数据唯一性标识：例如在分布式系统中使用一致性哈希来确定节点位置。

常见的哈希函数包括MD5、SHA-1、SHA-256等，它们能够快速生成具有较低冲突率（即不同输入得到相同输出的概率很小）的哈希值。然而，在安全敏感场景下，通常需要使用更强大的哈希函数来抵抗攻击，如SHA-3或Blake2。

<h2 id="13.介绍一下二叉树">13.介绍一下二叉树</h2>

二叉树（Binary Tree）是一种常见的树形数据结构，它由节点（Node）组成，每个节点最多有两个子节点：左子节点和右子节点。

二叉树的特点如下：

    每个节点最多有两个子节点，分别称为左子节点和右子节点。
    左子树和右子树也是二叉树，可以为空。
    二叉树没有环路（即不存在从某个节点出发经过若干条边回到该节点的路径）。

在二叉树中，通常会定义以下几种特殊类型的二叉树：

    完全二叉树

（Complete Binary Tree）：除了最后一层外，其他层的所有节点都必须是满的，并且最后一层的所有节点都尽量靠左排列。
满二叉树

    （Full Binary Tree）：除了叶子节点外，每个内部节点都有两个子节点。
    二叉搜索树（Binary Search Tree）：对于任意一个节点，其左子树上的值都小于等于该节点的值，右子树上的值都大于等于该节点的值。这种性质使得查找、插入和删除操作非常高效。

二叉树可以用递归或迭代方式进行遍历，常见的遍历方式包括：

    前序遍历（Preorder Traversal）：先访问根节点，然后按照前序遍历顺序递归地遍历左子树和右子树。
    中序遍历（Inorder Traversal）：先按照中序遍历顺序递归地遍历左子树，然后访问根节点，最后再递归地遍历右子树。
    后序遍历（Postorder Traversal）：先按照后序遍历顺序递归地遍历左子树和右子树，最后访问根节点。

二叉树在计算机科学中有广泛应用，例如表示算术表达式、数据库索引结构、图形渲染等。


<h2 id="14.编程实现LRU">14.编程实现LRU</h2>
LRU（Least Recently Used，最近最少使用）是一种常用的缓存淘汰策略。

下面是一个手撕LRU缓存的示例实现：

#include <iostream>
#include <unordered_map>
#include <list>

using namespace std;

class LRUCache {
private:
    int capacity;
    unordered_map<int, pair<int, list<int>::iterator>> cache;  // 存储键值对和对应迭代器
    list<int> lruList;  // 存储访问顺序

public:
    LRUCache(int cap) {
        capacity = cap;
    }

    int get(int key) {
        if (cache.find(key) == cache.end()) {  // 若key不存在于缓存中
            return -1;
        }

        // 将该元素移到链表头部表示最新访问
        lruList.erase(cache[key].second);
        lruList.push_front(key);
        cache[key].second = lruList.begin();

        return cache[key].first;  // 返回对应value值
    }

    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {  // 若key已存在于缓存中，则更新value，并将其移到链表头部表示最新访问
            lruList.erase(cache[key].second);
            lruList.push_front(key);
            cache[key] = make_pair(value, lruList.begin());
            return;
        }

        if (cache.size() == capacity) {  // 缓存已满，需要淘汰末尾的元素（即最久未使用）
            int lastKey = lruList.back();
            cache.erase(lastKey);
            lruList.pop_back();
        }

        // 插入新元素到链表头部表示最新访问
        lruList.push_front(key);
        cache[key] = make_pair(value, lruList.begin());
    }
};

int main() {
    LRUCache cache(2);  // 创建容量为2的LRU缓存

    cache.put(1, 1);
    cache.put(2, 2);
    cout << cache.get(1) << endl;  // 输出：1
    cache.put(3, 3); 
    cout << cache.get(2) << endl;  // 输出：-1，因为key=2被淘汰了
    cache.put(4, 4);
    cout << cache.get(1) << endl;  // 输出：-1，因为key=1被淘汰了
    cout << cache.get(3) << endl;  // 输出：3
    cout << cache.get(4) << endl;  // 输出：4

    return 0;
}

<h2 id="15.编程实现memcopy">15.编程实现memcopy</h2>

memcpy是一个用于内存拷贝的标准库函数。下面是一个手撕memcpy函数的简单实现：

#include <iostream>

void myMemcpy(void* dest, const void* src, size_t size) {
    char* destPtr = static_cast<char*>(dest);
    const char* srcPtr = static_cast<const char*>(src);

    for (size_t i = 0; i < size; ++i) {
        destPtr[i] = srcPtr[i];
    }
}

int main() {
    int source[] = {1, 2, 3, 4, 5};
    int destination[5];

    myMemcpy(destination, source, sizeof(source));

    for (const auto& element : destination) {
        std::cout << element << " ";
    }
    
    return 0;
}

在这个示例中，myMemcpy函数接受三个参数：目标指针 dest、源指针 src 和要拷贝的字节数 size。通过将指针转换为 char* 类型，我们可以按字节进行拷贝。然后，使用一个循环来逐字节地将源数据复制到目标内存中。

注意，在实际开发中，建议使用标准库提供的 memcpy 函数或其他相关的安全替代品，以确保更高的效率和正确性。上述手撕版本只是为了演示原理，并不考虑边界情况和优化处理。



